{"ast":null,"code":"import base64url from 'base64url';\n\nconst generateToken = function (privateKey) {\n  let seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 86400 * 10000;\n  const idData = {\n    createdBy: privateKeyToAddress(privateKey),\n    validUntil: Math.floor(Date.now() / 1000) + seconds\n  };\n  return base64url(serializeForHashing({\n    idData,\n    signature: sign(privateKey, idData)\n  }));\n};\n\nconst privateKeyToAddress = privateKey => window.web3.eth.accounts.privateKeyToAccount(privateKey).address;\n\nconst serializeForHashing = object => {\n  const isDict = subject => typeof subject === 'object' && !Array.isArray(subject);\n\n  const isString = subject => typeof subject === 'string';\n\n  const isArray = subject => Array.isArray(subject);\n\n  if (isDict(object)) {\n    const content = Object.keys(object).sort().map(key => `\"${key}\":${serializeForHashing(object[key])}`).join(',');\n    return `{${content}}`;\n  }\n\n  if (isArray(object)) {\n    const content = object.map(item => serializeForHashing(item)).join(',');\n    return `[${content}]`;\n  }\n\n  if (isString(object)) {\n    return `\"${object}\"`;\n  }\n\n  return object.toString();\n};\n\nconst sign = (privateKey, data) => window.web3.eth.accounts.sign(serializeForHashing(data), privateKey).signature;\n\nexport default generateToken;","map":{"version":3,"sources":["/Users/melnychenkovadim/WebstormProjects/dashboard-redisgn/hermes-dashboard-redesign/src/utils/generateToken.js"],"names":["base64url","generateToken","privateKey","seconds","idData","createdBy","privateKeyToAddress","validUntil","Math","floor","Date","now","serializeForHashing","signature","sign","window","web3","eth","accounts","privateKeyToAccount","address","object","isDict","subject","Array","isArray","isString","content","Object","keys","sort","map","key","join","item","toString","data"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,WAAtB;;AAEA,MAAMC,aAAa,GAAG,UAACC,UAAD,EAAyC;AAAA,MAA5BC,OAA4B,uEAAlB,QAAQ,KAAU;AAC7D,QAAMC,MAAM,GAAG;AACbC,IAAAA,SAAS,EAAEC,mBAAmB,CAACJ,UAAD,CADjB;AAEbK,IAAAA,UAAU,EAAEC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgCR;AAF/B,GAAf;AAKA,SAAOH,SAAS,CACdY,mBAAmB,CAAC;AAClBR,IAAAA,MADkB;AAElBS,IAAAA,SAAS,EAAEC,IAAI,CAACZ,UAAD,EAAaE,MAAb;AAFG,GAAD,CADL,CAAhB;AAMD,CAZD;;AAcA,MAAME,mBAAmB,GAAIJ,UAAD,IAC1Ba,MAAM,CAACC,IAAP,CAAYC,GAAZ,CAAgBC,QAAhB,CAAyBC,mBAAzB,CAA6CjB,UAA7C,EAAyDkB,OAD3D;;AAGA,MAAMR,mBAAmB,GAAIS,MAAD,IAAY;AACtC,QAAMC,MAAM,GAAIC,OAAD,IACb,OAAOA,OAAP,KAAmB,QAAnB,IAA+B,CAACC,KAAK,CAACC,OAAN,CAAcF,OAAd,CADlC;;AAEA,QAAMG,QAAQ,GAAIH,OAAD,IAAa,OAAOA,OAAP,KAAmB,QAAjD;;AACA,QAAME,OAAO,GAAIF,OAAD,IAAaC,KAAK,CAACC,OAAN,CAAcF,OAAd,CAA7B;;AAEA,MAAID,MAAM,CAACD,MAAD,CAAV,EAAoB;AAClB,UAAMM,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYR,MAAZ,EACbS,IADa,GAEbC,GAFa,CAERC,GAAD,IAAU,IAAGA,GAAI,KAAIpB,mBAAmB,CAACS,MAAM,CAACW,GAAD,CAAP,CAAc,EAF7C,EAGbC,IAHa,CAGR,GAHQ,CAAhB;AAIA,WAAQ,IAAGN,OAAQ,GAAnB;AACD;;AACD,MAAIF,OAAO,CAACJ,MAAD,CAAX,EAAqB;AACnB,UAAMM,OAAO,GAAGN,MAAM,CAACU,GAAP,CAAYG,IAAD,IAAUtB,mBAAmB,CAACsB,IAAD,CAAxC,EAAgDD,IAAhD,CAAqD,GAArD,CAAhB;AACA,WAAQ,IAAGN,OAAQ,GAAnB;AACD;;AACD,MAAID,QAAQ,CAACL,MAAD,CAAZ,EAAsB;AACpB,WAAQ,IAAGA,MAAO,GAAlB;AACD;;AACD,SAAOA,MAAM,CAACc,QAAP,EAAP;AACD,CArBD;;AAuBA,MAAMrB,IAAI,GAAG,CAACZ,UAAD,EAAakC,IAAb,KACXrB,MAAM,CAACC,IAAP,CAAYC,GAAZ,CAAgBC,QAAhB,CAAyBJ,IAAzB,CAA8BF,mBAAmB,CAACwB,IAAD,CAAjD,EAAyDlC,UAAzD,EACGW,SAFL;;AAIA,eAAeZ,aAAf","sourcesContent":["import base64url from 'base64url';\n\nconst generateToken = (privateKey, seconds = 86400 * 10000) => {\n  const idData = {\n    createdBy: privateKeyToAddress(privateKey),\n    validUntil: Math.floor(Date.now() / 1000) + seconds,\n  };\n\n  return base64url(\n    serializeForHashing({\n      idData,\n      signature: sign(privateKey, idData),\n    }),\n  );\n};\n\nconst privateKeyToAddress = (privateKey) =>\n  window.web3.eth.accounts.privateKeyToAccount(privateKey).address;\n\nconst serializeForHashing = (object) => {\n  const isDict = (subject) =>\n    typeof subject === 'object' && !Array.isArray(subject);\n  const isString = (subject) => typeof subject === 'string';\n  const isArray = (subject) => Array.isArray(subject);\n\n  if (isDict(object)) {\n    const content = Object.keys(object)\n      .sort()\n      .map((key) => `\"${key}\":${serializeForHashing(object[key])}`)\n      .join(',');\n    return `{${content}}`;\n  }\n  if (isArray(object)) {\n    const content = object.map((item) => serializeForHashing(item)).join(',');\n    return `[${content}]`;\n  }\n  if (isString(object)) {\n    return `\"${object}\"`;\n  }\n  return object.toString();\n};\n\nconst sign = (privateKey, data) =>\n  window.web3.eth.accounts.sign(serializeForHashing(data), privateKey)\n    .signature;\n\nexport default generateToken;\n"]},"metadata":{},"sourceType":"module"}