{"ast":null,"code":"/**\n *\n * @namespace faker.address\n */\nfunction Address(faker) {\n  var f = faker.fake,\n      Helpers = faker.helpers;\n  /**\n   * Generates random zipcode from format. If format is not specified, the\n   * locale's zip format is used.\n   *\n   * @method faker.address.zipCode\n   * @param {String} format\n   */\n\n  this.zipCode = function (format) {\n    // if zip format is not specified, use the zip format defined for the locale\n    if (typeof format === 'undefined') {\n      var localeFormat = faker.definitions.address.postcode;\n\n      if (typeof localeFormat === 'string') {\n        format = localeFormat;\n      } else {\n        format = faker.random.arrayElement(localeFormat);\n      }\n    }\n\n    return Helpers.replaceSymbols(format);\n  };\n  /**\n   * Generates random zipcode from state abbreviation. If state abbreviation is\n   * not specified, a random zip code is generated according to the locale's zip format.\n   * Only works for locales with postcode_by_state definition. If a locale does not\n   * have a postcode_by_state definition, a random zip code is generated according\n   * to the locale's zip format.\n   *\n   * @method faker.address.zipCodeByState\n   * @param {String} state\n   */\n\n\n  this.zipCodeByState = function (state) {\n    var zipRange = faker.definitions.address.postcode_by_state[state];\n\n    if (zipRange) {\n      return faker.datatype.number(zipRange);\n    }\n\n    return faker.address.zipCode();\n  };\n  /**\n   * Generates a random localized city name. The format string can contain any\n   * method provided by faker wrapped in `{{}}`, e.g. `{{name.firstName}}` in\n   * order to build the city name.\n   *\n   * If no format string is provided one of the following is randomly used:\n   *\n   * * `{{address.cityPrefix}} {{name.firstName}}{{address.citySuffix}}`\n   * * `{{address.cityPrefix}} {{name.firstName}}`\n   * * `{{name.firstName}}{{address.citySuffix}}`\n   * * `{{name.lastName}}{{address.citySuffix}}`\n   * * `{{address.cityName}}` when city name is available\n   *\n   * @method faker.address.city\n   * @param {String} format\n   */\n\n\n  this.city = function (format) {\n    var formats = ['{{address.cityPrefix}} {{name.firstName}}{{address.citySuffix}}', '{{address.cityPrefix}} {{name.firstName}}', '{{name.firstName}}{{address.citySuffix}}', '{{name.lastName}}{{address.citySuffix}}'];\n\n    if (!format && faker.definitions.address.city_name) {\n      formats.push('{{address.cityName}}');\n    }\n\n    if (typeof format !== \"number\") {\n      format = faker.datatype.number(formats.length - 1);\n    }\n\n    return f(formats[format]);\n  };\n  /**\n   * Return a random localized city prefix\n   * @method faker.address.cityPrefix\n   */\n\n\n  this.cityPrefix = function () {\n    return faker.random.arrayElement(faker.definitions.address.city_prefix);\n  };\n  /**\n   * Return a random localized city suffix\n   *\n   * @method faker.address.citySuffix\n   */\n\n\n  this.citySuffix = function () {\n    return faker.random.arrayElement(faker.definitions.address.city_suffix);\n  };\n  /**\n   * Returns a random city name\n   * \n   * @method faker.address.cityName\n   */\n\n\n  this.cityName = function () {\n    return faker.random.arrayElement(faker.definitions.address.city_name);\n  };\n  /**\n   * Returns a random localized street name\n   *\n   * @method faker.address.streetName\n   */\n\n\n  this.streetName = function () {\n    var result;\n    var suffix = faker.address.streetSuffix();\n\n    if (suffix !== \"\") {\n      suffix = \" \" + suffix;\n    }\n\n    switch (faker.datatype.number(1)) {\n      case 0:\n        result = faker.name.lastName() + suffix;\n        break;\n\n      case 1:\n        result = faker.name.firstName() + suffix;\n        break;\n    }\n\n    return result;\n  }; //\n  // TODO: change all these methods that accept a boolean to instead accept an options hash.\n  //\n\n  /**\n   * Returns a random localized street address\n   *\n   * @method faker.address.streetAddress\n   * @param {Boolean} useFullAddress\n   */\n\n\n  this.streetAddress = function (useFullAddress) {\n    if (useFullAddress === undefined) {\n      useFullAddress = false;\n    }\n\n    var address = \"\";\n\n    switch (faker.datatype.number(2)) {\n      case 0:\n        address = Helpers.replaceSymbolWithNumber(\"#####\") + \" \" + faker.address.streetName();\n        break;\n\n      case 1:\n        address = Helpers.replaceSymbolWithNumber(\"####\") + \" \" + faker.address.streetName();\n        break;\n\n      case 2:\n        address = Helpers.replaceSymbolWithNumber(\"###\") + \" \" + faker.address.streetName();\n        break;\n    }\n\n    return useFullAddress ? address + \" \" + faker.address.secondaryAddress() : address;\n  };\n  /**\n   * streetSuffix\n   *\n   * @method faker.address.streetSuffix\n   */\n\n\n  this.streetSuffix = function () {\n    return faker.random.arrayElement(faker.definitions.address.street_suffix);\n  };\n  /**\n   * streetPrefix\n   *\n   * @method faker.address.streetPrefix\n   */\n\n\n  this.streetPrefix = function () {\n    return faker.random.arrayElement(faker.definitions.address.street_prefix);\n  };\n  /**\n   * secondaryAddress\n   *\n   * @method faker.address.secondaryAddress\n   */\n\n\n  this.secondaryAddress = function () {\n    return Helpers.replaceSymbolWithNumber(faker.random.arrayElement(['Apt. ###', 'Suite ###']));\n  };\n  /**\n   * county\n   *\n   * @method faker.address.county\n   */\n\n\n  this.county = function () {\n    return faker.random.arrayElement(faker.definitions.address.county);\n  };\n  /**\n   * country\n   *\n   * @method faker.address.country\n   */\n\n\n  this.country = function () {\n    return faker.random.arrayElement(faker.definitions.address.country);\n  };\n  /**\n   * countryCode\n   *\n   * @method faker.address.countryCode\n   * @param {string} alphaCode default alpha-2\n   */\n\n\n  this.countryCode = function (alphaCode) {\n    if (typeof alphaCode === 'undefined' || alphaCode === 'alpha-2') {\n      return faker.random.arrayElement(faker.definitions.address.country_code);\n    }\n\n    if (alphaCode === 'alpha-3') {\n      return faker.random.arrayElement(faker.definitions.address.country_code_alpha_3);\n    }\n\n    return faker.random.arrayElement(faker.definitions.address.country_code);\n  };\n  /**\n   * state\n   *\n   * @method faker.address.state\n   * @param {Boolean} useAbbr\n   */\n\n\n  this.state = function (useAbbr) {\n    return faker.random.arrayElement(faker.definitions.address.state);\n  };\n  /**\n   * stateAbbr\n   *\n   * @method faker.address.stateAbbr\n   */\n\n\n  this.stateAbbr = function () {\n    return faker.random.arrayElement(faker.definitions.address.state_abbr);\n  };\n  /**\n   * latitude\n   *\n   * @method faker.address.latitude\n   * @param {Double} max default is 90\n   * @param {Double} min default is -90\n   * @param {number} precision default is 4\n   */\n\n\n  this.latitude = function (max, min, precision) {\n    max = max || 90;\n    min = min || -90;\n    precision = precision || 4;\n    return faker.datatype.number({\n      max: max,\n      min: min,\n      precision: parseFloat(0.0.toPrecision(precision) + '1')\n    }).toFixed(precision);\n  };\n  /**\n   * longitude\n   *\n   * @method faker.address.longitude\n   * @param {Double} max default is 180\n   * @param {Double} min default is -180\n   * @param {number} precision default is 4\n   */\n\n\n  this.longitude = function (max, min, precision) {\n    max = max || 180;\n    min = min || -180;\n    precision = precision || 4;\n    return faker.datatype.number({\n      max: max,\n      min: min,\n      precision: parseFloat(0.0.toPrecision(precision) + '1')\n    }).toFixed(precision);\n  };\n  /**\n   *  direction\n   *\n   * @method faker.address.direction\n   * @param {Boolean} useAbbr return direction abbreviation. defaults to false\n   */\n\n\n  this.direction = function (useAbbr) {\n    if (typeof useAbbr === 'undefined' || useAbbr === false) {\n      return faker.random.arrayElement(faker.definitions.address.direction);\n    }\n\n    return faker.random.arrayElement(faker.definitions.address.direction_abbr);\n  };\n\n  this.direction.schema = {\n    \"description\": \"Generates a direction. Use optional useAbbr bool to return abbreviation\",\n    \"sampleResults\": [\"Northwest\", \"South\", \"SW\", \"E\"]\n  };\n  /**\n   * cardinal direction\n   *\n   * @method faker.address.cardinalDirection\n   * @param {Boolean} useAbbr return direction abbreviation. defaults to false\n   */\n\n  this.cardinalDirection = function (useAbbr) {\n    if (typeof useAbbr === 'undefined' || useAbbr === false) {\n      return faker.random.arrayElement(faker.definitions.address.direction.slice(0, 4));\n    }\n\n    return faker.random.arrayElement(faker.definitions.address.direction_abbr.slice(0, 4));\n  };\n\n  this.cardinalDirection.schema = {\n    \"description\": \"Generates a cardinal direction. Use optional useAbbr boolean to return abbreviation\",\n    \"sampleResults\": [\"North\", \"South\", \"E\", \"W\"]\n  };\n  /**\n   * ordinal direction\n   *\n   * @method faker.address.ordinalDirection\n   * @param {Boolean} useAbbr return direction abbreviation. defaults to false\n   */\n\n  this.ordinalDirection = function (useAbbr) {\n    if (typeof useAbbr === 'undefined' || useAbbr === false) {\n      return faker.random.arrayElement(faker.definitions.address.direction.slice(4, 8));\n    }\n\n    return faker.random.arrayElement(faker.definitions.address.direction_abbr.slice(4, 8));\n  };\n\n  this.ordinalDirection.schema = {\n    \"description\": \"Generates an ordinal direction. Use optional useAbbr boolean to return abbreviation\",\n    \"sampleResults\": [\"Northwest\", \"Southeast\", \"SW\", \"NE\"]\n  };\n\n  this.nearbyGPSCoordinate = function (coordinate, radius, isMetric) {\n    function randomFloat(min, max) {\n      return Math.random() * (max - min) + min;\n    }\n\n    function degreesToRadians(degrees) {\n      return degrees * (Math.PI / 180.0);\n    }\n\n    function radiansToDegrees(radians) {\n      return radians * (180.0 / Math.PI);\n    }\n\n    function kilometersToMiles(miles) {\n      return miles * 0.621371;\n    }\n\n    function coordinateWithOffset(coordinate, bearing, distance, isMetric) {\n      var R = 6378.137; // Radius of the Earth (http://nssdc.gsfc.nasa.gov/planetary/factsheet/earthfact.html)\n\n      var d = isMetric ? distance : kilometersToMiles(distance); // Distance in km\n\n      var lat1 = degreesToRadians(coordinate[0]); //Current lat point converted to radians\n\n      var lon1 = degreesToRadians(coordinate[1]); //Current long point converted to radians\n\n      var lat2 = Math.asin(Math.sin(lat1) * Math.cos(d / R) + Math.cos(lat1) * Math.sin(d / R) * Math.cos(bearing));\n      var lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(d / R) * Math.cos(lat1), Math.cos(d / R) - Math.sin(lat1) * Math.sin(lat2)); // Keep longitude in range [-180, 180]\n\n      if (lon2 > degreesToRadians(180)) {\n        lon2 = lon2 - degreesToRadians(360);\n      } else if (lon2 < degreesToRadians(-180)) {\n        lon2 = lon2 + degreesToRadians(360);\n      }\n\n      return [radiansToDegrees(lat2), radiansToDegrees(lon2)];\n    } // If there is no coordinate, the best we can do is return a random GPS coordinate.\n\n\n    if (coordinate === undefined) {\n      return [faker.address.latitude(), faker.address.longitude()];\n    }\n\n    radius = radius || 10.0;\n    isMetric = isMetric || false; // TODO: implement either a gaussian/uniform distribution of points in cicular region.\n    // Possibly include param to function that allows user to choose between distributions.\n    // This approach will likely result in a higher density of points near the center.\n\n    var randomCoord = coordinateWithOffset(coordinate, degreesToRadians(Math.random() * 360.0), radius, isMetric);\n    return [randomCoord[0].toFixed(4), randomCoord[1].toFixed(4)];\n  };\n  /**\n     * Return a random time zone\n     * @method faker.address.timeZone\n     */\n\n\n  this.timeZone = function () {\n    return faker.random.arrayElement(faker.definitions.address.time_zone);\n  };\n\n  return this;\n}\n\nmodule.exports = Address;","map":{"version":3,"sources":["/Users/melnychenkovadim/WebstormProjects/dashboard-redisgn/hermes-dashboard-redesign/node_modules/faker/lib/address.js"],"names":["Address","faker","f","fake","Helpers","helpers","zipCode","format","localeFormat","definitions","address","postcode","random","arrayElement","replaceSymbols","zipCodeByState","state","zipRange","postcode_by_state","datatype","number","city","formats","city_name","push","length","cityPrefix","city_prefix","citySuffix","city_suffix","cityName","streetName","result","suffix","streetSuffix","name","lastName","firstName","streetAddress","useFullAddress","undefined","replaceSymbolWithNumber","secondaryAddress","street_suffix","streetPrefix","street_prefix","county","country","countryCode","alphaCode","country_code","country_code_alpha_3","useAbbr","stateAbbr","state_abbr","latitude","max","min","precision","parseFloat","toPrecision","toFixed","longitude","direction","direction_abbr","schema","cardinalDirection","slice","ordinalDirection","nearbyGPSCoordinate","coordinate","radius","isMetric","randomFloat","Math","degreesToRadians","degrees","PI","radiansToDegrees","radians","kilometersToMiles","miles","coordinateWithOffset","bearing","distance","R","d","lat1","lon1","lat2","asin","sin","cos","lon2","atan2","randomCoord","timeZone","time_zone","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,OAAT,CAAkBC,KAAlB,EAAyB;AACvB,MAAIC,CAAC,GAAGD,KAAK,CAACE,IAAd;AAAA,MACEC,OAAO,GAAGH,KAAK,CAACI,OADlB;AAGA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,OAAL,GAAe,UAASC,MAAT,EAAiB;AAC9B;AACA,QAAI,OAAOA,MAAP,KAAkB,WAAtB,EAAmC;AACjC,UAAIC,YAAY,GAAGP,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BC,QAA7C;;AACA,UAAI,OAAOH,YAAP,KAAwB,QAA5B,EAAsC;AACpCD,QAAAA,MAAM,GAAGC,YAAT;AACD,OAFD,MAEO;AACLD,QAAAA,MAAM,GAAGN,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BL,YAA1B,CAAT;AACD;AACF;;AACD,WAAOJ,OAAO,CAACU,cAAR,CAAuBP,MAAvB,CAAP;AACD,GAXD;AAaA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,OAAKQ,cAAL,GAAsB,UAAUC,KAAV,EAAiB;AACrC,QAAIC,QAAQ,GAAGhB,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BQ,iBAA1B,CAA4CF,KAA5C,CAAf;;AACA,QAAIC,QAAJ,EAAc;AACZ,aAAOhB,KAAK,CAACkB,QAAN,CAAeC,MAAf,CAAsBH,QAAtB,CAAP;AACD;;AACD,WAAOhB,KAAK,CAACS,OAAN,CAAcJ,OAAd,EAAP;AACD,GAND;AAQA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,OAAKe,IAAL,GAAY,UAAUd,MAAV,EAAkB;AAC5B,QAAIe,OAAO,GAAG,CACZ,iEADY,EAEZ,2CAFY,EAGZ,0CAHY,EAIZ,yCAJY,CAAd;;AAOA,QAAI,CAACf,MAAD,IAAWN,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0Ba,SAAzC,EAAoD;AAClDD,MAAAA,OAAO,CAACE,IAAR,CAAa,sBAAb;AACD;;AAED,QAAI,OAAOjB,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,MAAAA,MAAM,GAAGN,KAAK,CAACkB,QAAN,CAAeC,MAAf,CAAsBE,OAAO,CAACG,MAAR,GAAiB,CAAvC,CAAT;AACD;;AAED,WAAOvB,CAAC,CAACoB,OAAO,CAACf,MAAD,CAAR,CAAR;AAED,GAlBD;AAoBA;AACF;AACA;AACA;;;AACE,OAAKmB,UAAL,GAAkB,YAAY;AAC5B,WAAOzB,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BiB,WAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKC,UAAL,GAAkB,YAAY;AAC5B,WAAO3B,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BmB,WAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKC,QAAL,GAAgB,YAAW;AACzB,WAAO7B,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0Ba,SAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKQ,UAAL,GAAkB,YAAY;AAC5B,QAAIC,MAAJ;AACA,QAAIC,MAAM,GAAGhC,KAAK,CAACS,OAAN,CAAcwB,YAAd,EAAb;;AACA,QAAID,MAAM,KAAK,EAAf,EAAmB;AACjBA,MAAAA,MAAM,GAAG,MAAMA,MAAf;AACD;;AAED,YAAQhC,KAAK,CAACkB,QAAN,CAAeC,MAAf,CAAsB,CAAtB,CAAR;AACE,WAAK,CAAL;AACEY,QAAAA,MAAM,GAAG/B,KAAK,CAACkC,IAAN,CAAWC,QAAX,KAAwBH,MAAjC;AACA;;AACF,WAAK,CAAL;AACED,QAAAA,MAAM,GAAG/B,KAAK,CAACkC,IAAN,CAAWE,SAAX,KAAyBJ,MAAlC;AACA;AANJ;;AAQA,WAAOD,MAAP;AACD,GAhBD,CA7GuB,CA+HvB;AACA;AACA;;AACA;AACF;AACA;AACA;AACA;AACA;;;AACE,OAAKM,aAAL,GAAqB,UAAUC,cAAV,EAA0B;AAC7C,QAAIA,cAAc,KAAKC,SAAvB,EAAkC;AAAED,MAAAA,cAAc,GAAG,KAAjB;AAAyB;;AAC7D,QAAI7B,OAAO,GAAG,EAAd;;AACA,YAAQT,KAAK,CAACkB,QAAN,CAAeC,MAAf,CAAsB,CAAtB,CAAR;AACE,WAAK,CAAL;AACEV,QAAAA,OAAO,GAAGN,OAAO,CAACqC,uBAAR,CAAgC,OAAhC,IAA2C,GAA3C,GAAiDxC,KAAK,CAACS,OAAN,CAAcqB,UAAd,EAA3D;AACA;;AACF,WAAK,CAAL;AACErB,QAAAA,OAAO,GAAGN,OAAO,CAACqC,uBAAR,CAAgC,MAAhC,IAA2C,GAA3C,GAAiDxC,KAAK,CAACS,OAAN,CAAcqB,UAAd,EAA3D;AACA;;AACF,WAAK,CAAL;AACErB,QAAAA,OAAO,GAAGN,OAAO,CAACqC,uBAAR,CAAgC,KAAhC,IAAyC,GAAzC,GAA+CxC,KAAK,CAACS,OAAN,CAAcqB,UAAd,EAAzD;AACA;AATJ;;AAWA,WAAOQ,cAAc,GAAI7B,OAAO,GAAG,GAAV,GAAgBT,KAAK,CAACS,OAAN,CAAcgC,gBAAd,EAApB,GAAwDhC,OAA7E;AACD,GAfD;AAiBA;AACF;AACA;AACA;AACA;;;AACE,OAAKwB,YAAL,GAAoB,YAAY;AAC9B,WAAOjC,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BiC,aAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKC,YAAL,GAAoB,YAAY;AAC9B,WAAO3C,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BmC,aAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKH,gBAAL,GAAwB,YAAY;AAClC,WAAOtC,OAAO,CAACqC,uBAAR,CAAgCxC,KAAK,CAACW,MAAN,CAAaC,YAAb,CACrC,CACE,UADF,EAEE,WAFF,CADqC,CAAhC,CAAP;AAMD,GAPD;AASA;AACF;AACA;AACA;AACA;;;AACE,OAAKiC,MAAL,GAAc,YAAY;AACxB,WAAO7C,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BoC,MAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKC,OAAL,GAAe,YAAY;AACzB,WAAO9C,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BqC,OAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;AACA;;;AACE,OAAKC,WAAL,GAAmB,UAAUC,SAAV,EAAqB;AAEtC,QAAI,OAAOA,SAAP,KAAqB,WAArB,IAAoCA,SAAS,KAAK,SAAtD,EAAiE;AAC/D,aAAOhD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BwC,YAApD,CAAP;AACD;;AAED,QAAID,SAAS,KAAK,SAAlB,EAA6B;AAC3B,aAAOhD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0ByC,oBAApD,CAAP;AACD;;AAED,WAAOlD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BwC,YAApD,CAAP;AAED,GAZD;AAcA;AACF;AACA;AACA;AACA;AACA;;;AACE,OAAKlC,KAAL,GAAa,UAAUoC,OAAV,EAAmB;AAC9B,WAAOnD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BM,KAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACE,OAAKqC,SAAL,GAAiB,YAAY;AAC3B,WAAOpD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0B4C,UAApD,CAAP;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,OAAKC,QAAL,GAAgB,UAAUC,GAAV,EAAeC,GAAf,EAAoBC,SAApB,EAA+B;AAC7CF,IAAAA,GAAG,GAASA,GAAG,IAAI,EAAnB;AACAC,IAAAA,GAAG,GAASA,GAAG,IAAI,CAAC,EAApB;AACAC,IAAAA,SAAS,GAAGA,SAAS,IAAI,CAAzB;AAEA,WAAOzD,KAAK,CAACkB,QAAN,CAAeC,MAAf,CAAsB;AAC3BoC,MAAAA,GAAG,EAAEA,GADsB;AAE3BC,MAAAA,GAAG,EAAEA,GAFsB;AAG3BC,MAAAA,SAAS,EAAEC,UAAU,CAAE,GAAD,CAAMC,WAAN,CAAkBF,SAAlB,IAA+B,GAAhC;AAHM,KAAtB,EAIJG,OAJI,CAIIH,SAJJ,CAAP;AAKD,GAVD;AAYA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,OAAKI,SAAL,GAAiB,UAAUN,GAAV,EAAeC,GAAf,EAAoBC,SAApB,EAA+B;AAC9CF,IAAAA,GAAG,GAASA,GAAG,IAAI,GAAnB;AACAC,IAAAA,GAAG,GAASA,GAAG,IAAI,CAAC,GAApB;AACAC,IAAAA,SAAS,GAAGA,SAAS,IAAI,CAAzB;AAEA,WAAOzD,KAAK,CAACkB,QAAN,CAAeC,MAAf,CAAsB;AAC3BoC,MAAAA,GAAG,EAAEA,GADsB;AAE3BC,MAAAA,GAAG,EAAEA,GAFsB;AAG3BC,MAAAA,SAAS,EAAEC,UAAU,CAAE,GAAD,CAAMC,WAAN,CAAkBF,SAAlB,IAA+B,GAAhC;AAHM,KAAtB,EAIJG,OAJI,CAIIH,SAJJ,CAAP;AAKD,GAVD;AAYA;AACF;AACA;AACA;AACA;AACA;;;AACE,OAAKK,SAAL,GAAiB,UAAUX,OAAV,EAAmB;AAClC,QAAI,OAAOA,OAAP,KAAmB,WAAnB,IAAkCA,OAAO,KAAK,KAAlD,EAAyD;AACvD,aAAOnD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BqD,SAApD,CAAP;AACD;;AACD,WAAO9D,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BsD,cAApD,CAAP;AACD,GALD;;AAOA,OAAKD,SAAL,CAAeE,MAAf,GAAwB;AACtB,mBAAe,yEADO;AAEtB,qBAAiB,CAAC,WAAD,EAAc,OAAd,EAAuB,IAAvB,EAA6B,GAA7B;AAFK,GAAxB;AAKA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyB,UAAUd,OAAV,EAAmB;AAC1C,QAAI,OAAOA,OAAP,KAAmB,WAAnB,IAAkCA,OAAO,KAAK,KAAlD,EAAyD;AACvD,aACEnD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BqD,SAA1B,CAAoCI,KAApC,CAA0C,CAA1C,EAA6C,CAA7C,CAA1B,CADF;AAGD;;AACD,WACElE,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BsD,cAA1B,CAAyCG,KAAzC,CAA+C,CAA/C,EAAkD,CAAlD,CAA1B,CADF;AAGD,GATD;;AAWA,OAAKD,iBAAL,CAAuBD,MAAvB,GAAgC;AAC9B,mBAAe,qFADe;AAE9B,qBAAiB,CAAC,OAAD,EAAU,OAAV,EAAmB,GAAnB,EAAwB,GAAxB;AAFa,GAAhC;AAKA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKG,gBAAL,GAAwB,UAAUhB,OAAV,EAAmB;AACzC,QAAI,OAAOA,OAAP,KAAmB,WAAnB,IAAkCA,OAAO,KAAK,KAAlD,EAAyD;AACvD,aACEnD,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BqD,SAA1B,CAAoCI,KAApC,CAA0C,CAA1C,EAA6C,CAA7C,CAA1B,CADF;AAGD;;AACD,WACElE,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BsD,cAA1B,CAAyCG,KAAzC,CAA+C,CAA/C,EAAkD,CAAlD,CAA1B,CADF;AAGD,GATD;;AAWA,OAAKC,gBAAL,CAAsBH,MAAtB,GAA+B;AAC7B,mBAAe,qFADc;AAE7B,qBAAiB,CAAC,WAAD,EAAc,WAAd,EAA2B,IAA3B,EAAiC,IAAjC;AAFY,GAA/B;;AAKA,OAAKI,mBAAL,GAA2B,UAASC,UAAT,EAAqBC,MAArB,EAA6BC,QAA7B,EAAuC;AAChE,aAASC,WAAT,CAAqBhB,GAArB,EAA0BD,GAA1B,EAA+B;AAC7B,aAAOkB,IAAI,CAAC9D,MAAL,MAAiB4C,GAAG,GAACC,GAArB,IAA4BA,GAAnC;AACD;;AACD,aAASkB,gBAAT,CAA0BC,OAA1B,EAAmC;AACjC,aAAOA,OAAO,IAAIF,IAAI,CAACG,EAAL,GAAQ,KAAZ,CAAd;AACD;;AACD,aAASC,gBAAT,CAA0BC,OAA1B,EAAmC;AACjC,aAAOA,OAAO,IAAI,QAAML,IAAI,CAACG,EAAf,CAAd;AACD;;AACD,aAASG,iBAAT,CAA2BC,KAA3B,EAAkC;AAChC,aAAOA,KAAK,GAAG,QAAf;AACD;;AACD,aAASC,oBAAT,CAA8BZ,UAA9B,EAA0Ca,OAA1C,EAAmDC,QAAnD,EAA6DZ,QAA7D,EAAuE;AACrE,UAAIa,CAAC,GAAG,QAAR,CADqE,CACnD;;AAClB,UAAIC,CAAC,GAAGd,QAAQ,GAAGY,QAAH,GAAcJ,iBAAiB,CAACI,QAAD,CAA/C,CAFqE,CAEV;;AAE3D,UAAIG,IAAI,GAAGZ,gBAAgB,CAACL,UAAU,CAAC,CAAD,CAAX,CAA3B,CAJqE,CAIzB;;AAC5C,UAAIkB,IAAI,GAAGb,gBAAgB,CAACL,UAAU,CAAC,CAAD,CAAX,CAA3B,CALqE,CAKzB;;AAE5C,UAAImB,IAAI,GAAGf,IAAI,CAACgB,IAAL,CAAUhB,IAAI,CAACiB,GAAL,CAASJ,IAAT,IAAiBb,IAAI,CAACkB,GAAL,CAASN,CAAC,GAACD,CAAX,CAAjB,GACXX,IAAI,CAACkB,GAAL,CAASL,IAAT,IAAiBb,IAAI,CAACiB,GAAL,CAASL,CAAC,GAACD,CAAX,CAAjB,GAAiCX,IAAI,CAACkB,GAAL,CAAST,OAAT,CADhC,CAAX;AAGA,UAAIU,IAAI,GAAGL,IAAI,GAAGd,IAAI,CAACoB,KAAL,CAChBpB,IAAI,CAACiB,GAAL,CAASR,OAAT,IAAoBT,IAAI,CAACiB,GAAL,CAASL,CAAC,GAACD,CAAX,CAApB,GAAoCX,IAAI,CAACkB,GAAL,CAASL,IAAT,CADpB,EAEhBb,IAAI,CAACkB,GAAL,CAASN,CAAC,GAACD,CAAX,IAAgBX,IAAI,CAACiB,GAAL,CAASJ,IAAT,IAAiBb,IAAI,CAACiB,GAAL,CAASF,IAAT,CAFjB,CAAlB,CAVqE,CAcrE;;AACA,UAAII,IAAI,GAAGlB,gBAAgB,CAAC,GAAD,CAA3B,EAAkC;AAChCkB,QAAAA,IAAI,GAAGA,IAAI,GAAGlB,gBAAgB,CAAC,GAAD,CAA9B;AACD,OAFD,MAEO,IAAIkB,IAAI,GAAGlB,gBAAgB,CAAC,CAAC,GAAF,CAA3B,EAAmC;AACxCkB,QAAAA,IAAI,GAAGA,IAAI,GAAGlB,gBAAgB,CAAC,GAAD,CAA9B;AACD;;AAED,aAAO,CAACG,gBAAgB,CAACW,IAAD,CAAjB,EAAyBX,gBAAgB,CAACe,IAAD,CAAzC,CAAP;AACD,KAnC+D,CAqChE;;;AACA,QAAIvB,UAAU,KAAK9B,SAAnB,EAA8B;AAC5B,aAAO,CAACvC,KAAK,CAACS,OAAN,CAAc6C,QAAd,EAAD,EAA2BtD,KAAK,CAACS,OAAN,CAAcoD,SAAd,EAA3B,CAAP;AACD;;AACDS,IAAAA,MAAM,GAAGA,MAAM,IAAI,IAAnB;AACAC,IAAAA,QAAQ,GAAGA,QAAQ,IAAI,KAAvB,CA1CgE,CA4ChE;AACA;AAEA;;AACA,QAAIuB,WAAW,GAAGb,oBAAoB,CAACZ,UAAD,EAAaK,gBAAgB,CAACD,IAAI,CAAC9D,MAAL,KAAgB,KAAjB,CAA7B,EAAsD2D,MAAtD,EAA8DC,QAA9D,CAAtC;AACA,WAAO,CAACuB,WAAW,CAAC,CAAD,CAAX,CAAelC,OAAf,CAAuB,CAAvB,CAAD,EAA4BkC,WAAW,CAAC,CAAD,CAAX,CAAelC,OAAf,CAAuB,CAAvB,CAA5B,CAAP;AACD,GAlDD;AAoDA;AACF;AACA;AACA;;;AACE,OAAKmC,QAAL,GAAgB,YAAW;AACzB,WAAO/F,KAAK,CAACW,MAAN,CAAaC,YAAb,CAA0BZ,KAAK,CAACQ,WAAN,CAAkBC,OAAlB,CAA0BuF,SAApD,CAAP;AACD,GAFD;;AAIA,SAAO,IAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiBnG,OAAjB","sourcesContent":["/**\n *\n * @namespace faker.address\n */\nfunction Address (faker) {\n  var f = faker.fake,\n    Helpers = faker.helpers;\n\n  /**\n   * Generates random zipcode from format. If format is not specified, the\n   * locale's zip format is used.\n   *\n   * @method faker.address.zipCode\n   * @param {String} format\n   */\n  this.zipCode = function(format) {\n    // if zip format is not specified, use the zip format defined for the locale\n    if (typeof format === 'undefined') {\n      var localeFormat = faker.definitions.address.postcode;\n      if (typeof localeFormat === 'string') {\n        format = localeFormat;\n      } else {\n        format = faker.random.arrayElement(localeFormat);\n      }\n    }\n    return Helpers.replaceSymbols(format);\n  }\n\n  /**\n   * Generates random zipcode from state abbreviation. If state abbreviation is\n   * not specified, a random zip code is generated according to the locale's zip format.\n   * Only works for locales with postcode_by_state definition. If a locale does not\n   * have a postcode_by_state definition, a random zip code is generated according\n   * to the locale's zip format.\n   *\n   * @method faker.address.zipCodeByState\n   * @param {String} state\n   */\n  this.zipCodeByState = function (state) {\n    var zipRange = faker.definitions.address.postcode_by_state[state];\n    if (zipRange) {\n      return faker.datatype.number(zipRange);\n    }\n    return faker.address.zipCode();\n  }\n\n  /**\n   * Generates a random localized city name. The format string can contain any\n   * method provided by faker wrapped in `{{}}`, e.g. `{{name.firstName}}` in\n   * order to build the city name.\n   *\n   * If no format string is provided one of the following is randomly used:\n   *\n   * * `{{address.cityPrefix}} {{name.firstName}}{{address.citySuffix}}`\n   * * `{{address.cityPrefix}} {{name.firstName}}`\n   * * `{{name.firstName}}{{address.citySuffix}}`\n   * * `{{name.lastName}}{{address.citySuffix}}`\n   * * `{{address.cityName}}` when city name is available\n   *\n   * @method faker.address.city\n   * @param {String} format\n   */\n  this.city = function (format) {\n    var formats = [\n      '{{address.cityPrefix}} {{name.firstName}}{{address.citySuffix}}',\n      '{{address.cityPrefix}} {{name.firstName}}',\n      '{{name.firstName}}{{address.citySuffix}}',\n      '{{name.lastName}}{{address.citySuffix}}'\n    ];\n\n    if (!format && faker.definitions.address.city_name) {\n      formats.push('{{address.cityName}}');\n    }\n\n    if (typeof format !== \"number\") {\n      format = faker.datatype.number(formats.length - 1);\n    }\n\n    return f(formats[format]);\n\n  }\n\n  /**\n   * Return a random localized city prefix\n   * @method faker.address.cityPrefix\n   */\n  this.cityPrefix = function () {\n    return faker.random.arrayElement(faker.definitions.address.city_prefix);\n  }\n\n  /**\n   * Return a random localized city suffix\n   *\n   * @method faker.address.citySuffix\n   */\n  this.citySuffix = function () {\n    return faker.random.arrayElement(faker.definitions.address.city_suffix);\n  }\n\n  /**\n   * Returns a random city name\n   * \n   * @method faker.address.cityName\n   */\n  this.cityName = function() {\n    return faker.random.arrayElement(faker.definitions.address.city_name);\n  }\n\n  /**\n   * Returns a random localized street name\n   *\n   * @method faker.address.streetName\n   */\n  this.streetName = function () {\n    var result;\n    var suffix = faker.address.streetSuffix();\n    if (suffix !== \"\") {\n      suffix = \" \" + suffix\n    }\n\n    switch (faker.datatype.number(1)) {\n      case 0:\n        result = faker.name.lastName() + suffix;\n        break;\n      case 1:\n        result = faker.name.firstName() + suffix;\n        break;\n    }\n    return result;\n  }\n\n  //\n  // TODO: change all these methods that accept a boolean to instead accept an options hash.\n  //\n  /**\n   * Returns a random localized street address\n   *\n   * @method faker.address.streetAddress\n   * @param {Boolean} useFullAddress\n   */\n  this.streetAddress = function (useFullAddress) {\n    if (useFullAddress === undefined) { useFullAddress = false; }\n    var address = \"\";\n    switch (faker.datatype.number(2)) {\n      case 0:\n        address = Helpers.replaceSymbolWithNumber(\"#####\") + \" \" + faker.address.streetName();\n        break;\n      case 1:\n        address = Helpers.replaceSymbolWithNumber(\"####\") +  \" \" + faker.address.streetName();\n        break;\n      case 2:\n        address = Helpers.replaceSymbolWithNumber(\"###\") + \" \" + faker.address.streetName();\n        break;\n    }\n    return useFullAddress ? (address + \" \" + faker.address.secondaryAddress()) : address;\n  }\n\n  /**\n   * streetSuffix\n   *\n   * @method faker.address.streetSuffix\n   */\n  this.streetSuffix = function () {\n    return faker.random.arrayElement(faker.definitions.address.street_suffix);\n  }\n\n  /**\n   * streetPrefix\n   *\n   * @method faker.address.streetPrefix\n   */\n  this.streetPrefix = function () {\n    return faker.random.arrayElement(faker.definitions.address.street_prefix);\n  }\n\n  /**\n   * secondaryAddress\n   *\n   * @method faker.address.secondaryAddress\n   */\n  this.secondaryAddress = function () {\n    return Helpers.replaceSymbolWithNumber(faker.random.arrayElement(\n      [\n        'Apt. ###',\n        'Suite ###'\n      ]\n    ));\n  }\n\n  /**\n   * county\n   *\n   * @method faker.address.county\n   */\n  this.county = function () {\n    return faker.random.arrayElement(faker.definitions.address.county);\n  }\n\n  /**\n   * country\n   *\n   * @method faker.address.country\n   */\n  this.country = function () {\n    return faker.random.arrayElement(faker.definitions.address.country);\n  }\n\n  /**\n   * countryCode\n   *\n   * @method faker.address.countryCode\n   * @param {string} alphaCode default alpha-2\n   */\n  this.countryCode = function (alphaCode) {\n    \n    if (typeof alphaCode === 'undefined' || alphaCode === 'alpha-2') {\n      return faker.random.arrayElement(faker.definitions.address.country_code);\n    }\n\n    if (alphaCode === 'alpha-3') {\n      return faker.random.arrayElement(faker.definitions.address.country_code_alpha_3);\n    }\n      \n    return faker.random.arrayElement(faker.definitions.address.country_code);\n\n  }\n\n  /**\n   * state\n   *\n   * @method faker.address.state\n   * @param {Boolean} useAbbr\n   */\n  this.state = function (useAbbr) {\n    return faker.random.arrayElement(faker.definitions.address.state);\n  }\n\n  /**\n   * stateAbbr\n   *\n   * @method faker.address.stateAbbr\n   */\n  this.stateAbbr = function () {\n    return faker.random.arrayElement(faker.definitions.address.state_abbr);\n  }\n\n  /**\n   * latitude\n   *\n   * @method faker.address.latitude\n   * @param {Double} max default is 90\n   * @param {Double} min default is -90\n   * @param {number} precision default is 4\n   */\n  this.latitude = function (max, min, precision) {\n    max       = max || 90\n    min       = min || -90\n    precision = precision || 4\n\n    return faker.datatype.number({\n      max: max,\n      min: min,\n      precision: parseFloat((0.0).toPrecision(precision) + '1')\n    }).toFixed(precision);\n  }\n\n  /**\n   * longitude\n   *\n   * @method faker.address.longitude\n   * @param {Double} max default is 180\n   * @param {Double} min default is -180\n   * @param {number} precision default is 4\n   */\n  this.longitude = function (max, min, precision) {\n    max       = max || 180\n    min       = min || -180\n    precision = precision || 4\n\n    return faker.datatype.number({\n      max: max,\n      min: min,\n      precision: parseFloat((0.0).toPrecision(precision) + '1')\n    }).toFixed(precision);\n  }\n\n  /**\n   *  direction\n   *\n   * @method faker.address.direction\n   * @param {Boolean} useAbbr return direction abbreviation. defaults to false\n   */\n  this.direction = function (useAbbr) {\n    if (typeof useAbbr === 'undefined' || useAbbr === false) {\n      return faker.random.arrayElement(faker.definitions.address.direction);\n    }\n    return faker.random.arrayElement(faker.definitions.address.direction_abbr);\n  }\n\n  this.direction.schema = {\n    \"description\": \"Generates a direction. Use optional useAbbr bool to return abbreviation\",\n    \"sampleResults\": [\"Northwest\", \"South\", \"SW\", \"E\"]\n  };\n\n  /**\n   * cardinal direction\n   *\n   * @method faker.address.cardinalDirection\n   * @param {Boolean} useAbbr return direction abbreviation. defaults to false\n   */\n  this.cardinalDirection = function (useAbbr) {\n    if (typeof useAbbr === 'undefined' || useAbbr === false) {\n      return (\n        faker.random.arrayElement(faker.definitions.address.direction.slice(0, 4))\n      );\n    }\n    return (\n      faker.random.arrayElement(faker.definitions.address.direction_abbr.slice(0, 4))\n    );\n  }\n\n  this.cardinalDirection.schema = {\n    \"description\": \"Generates a cardinal direction. Use optional useAbbr boolean to return abbreviation\",\n    \"sampleResults\": [\"North\", \"South\", \"E\", \"W\"]\n  };\n\n  /**\n   * ordinal direction\n   *\n   * @method faker.address.ordinalDirection\n   * @param {Boolean} useAbbr return direction abbreviation. defaults to false\n   */\n  this.ordinalDirection = function (useAbbr) {\n    if (typeof useAbbr === 'undefined' || useAbbr === false) {\n      return (\n        faker.random.arrayElement(faker.definitions.address.direction.slice(4, 8))\n      );\n    }\n    return (\n      faker.random.arrayElement(faker.definitions.address.direction_abbr.slice(4, 8))\n    );\n  }\n\n  this.ordinalDirection.schema = {\n    \"description\": \"Generates an ordinal direction. Use optional useAbbr boolean to return abbreviation\",\n    \"sampleResults\": [\"Northwest\", \"Southeast\", \"SW\", \"NE\"]\n  };\n\n  this.nearbyGPSCoordinate = function(coordinate, radius, isMetric) {\n    function randomFloat(min, max) {\n      return Math.random() * (max-min) + min;\n    }\n    function degreesToRadians(degrees) {\n      return degrees * (Math.PI/180.0);\n    }\n    function radiansToDegrees(radians) {\n      return radians * (180.0/Math.PI);\n    }\n    function kilometersToMiles(miles) {\n      return miles * 0.621371;\n    }\n    function coordinateWithOffset(coordinate, bearing, distance, isMetric) {\n      var R = 6378.137; // Radius of the Earth (http://nssdc.gsfc.nasa.gov/planetary/factsheet/earthfact.html)\n      var d = isMetric ? distance : kilometersToMiles(distance); // Distance in km\n\n      var lat1 = degreesToRadians(coordinate[0]); //Current lat point converted to radians\n      var lon1 = degreesToRadians(coordinate[1]); //Current long point converted to radians\n\n      var lat2 = Math.asin(Math.sin(lat1) * Math.cos(d/R) +\n                Math.cos(lat1) * Math.sin(d/R) * Math.cos(bearing));\n\n      var lon2 = lon1 + Math.atan2(\n        Math.sin(bearing) * Math.sin(d/R) * Math.cos(lat1),\n        Math.cos(d/R) - Math.sin(lat1) * Math.sin(lat2));\n\n      // Keep longitude in range [-180, 180]\n      if (lon2 > degreesToRadians(180)) {\n        lon2 = lon2 - degreesToRadians(360);\n      } else if (lon2 < degreesToRadians(-180)) {\n        lon2 = lon2 + degreesToRadians(360);\n      }\n\n      return [radiansToDegrees(lat2), radiansToDegrees(lon2)];\n    }\n\n    // If there is no coordinate, the best we can do is return a random GPS coordinate.\n    if (coordinate === undefined) {\n      return [faker.address.latitude(), faker.address.longitude()]\n    }\n    radius = radius || 10.0;\n    isMetric = isMetric || false;\n\n    // TODO: implement either a gaussian/uniform distribution of points in cicular region.\n    // Possibly include param to function that allows user to choose between distributions.\n\n    // This approach will likely result in a higher density of points near the center.\n    var randomCoord = coordinateWithOffset(coordinate, degreesToRadians(Math.random() * 360.0), radius, isMetric);\n    return [randomCoord[0].toFixed(4), randomCoord[1].toFixed(4)];\n  }\n\n  /**\n     * Return a random time zone\n     * @method faker.address.timeZone\n     */\n  this.timeZone = function() {\n    return faker.random.arrayElement(faker.definitions.address.time_zone);\n  }\n\n  return this;\n}\n\nmodule.exports = Address;\n"]},"metadata":{},"sourceType":"script"}